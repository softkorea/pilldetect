<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pill Counter (Top-Hat & Slider)</title>
    <style>
        body { 
            display: flex; flex-direction: column; align-items: center; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0; padding: 10px; box-sizing: border-box; background: #222; color: #eee;
            touch-action: manipulation;
        }
        h3 { margin: 5px 0; color: #fff; font-size: 18px; }
        #status { font-size: 13px; color: #ccc; margin-bottom: 5px; height: 18px; }
        
        .container { 
            position: relative; 
            width: 100%; max-width: 640px; 
            aspect-ratio: 3 / 4; 
            background: #000;
            border-radius: 12px; overflow: hidden; box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        
        canvas { width: 100%; height: 100%; object-fit: cover; }
        #videoInput { display: none; }

        /* 슬라이더 컨트롤 UI */
        .controls-area {
            width: 100%; max-width: 640px; margin-top: 15px;
            background: #333; padding: 15px; border-radius: 12px;
        }

        .slider-container {
            display: flex; flex-direction: column; gap: 8px; margin-bottom: 15px;
        }
        .slider-header { display: flex; justify-content: space-between; font-weight: bold; font-size: 14px; }
        input[type=range] { width: 100%; height: 25px; accent-color: #0a84ff; }
        .tip { font-size: 12px; color: #aaa; }

        .btn-group { display: flex; gap: 10px; }
        button { 
            flex: 1; padding: 12px; font-size: 16px; font-weight: 600;
            cursor: pointer; border-radius: 8px; border: none; 
            background: #0a84ff; color: white;
        }
        button:disabled { background: #555; color: #888; }
        button#stopBtn { background: #ff453a; }
        button#stopBtn:disabled { background: #555; }

        .options { margin-top: 10px; font-size: 14px; display: flex; align-items: center; gap: 8px; }
        input[type=checkbox] { width: 18px; height: 18px; }
    </style>
</head>
<body>

    <h3>알약 정밀 카운터 (비닐 제거용)</h3>
    <div id="status">OpenCV 로딩 중...</div>
    
    <div class="container">
        <video id="videoInput" playsinline webkit-playsinline muted></video>
        <canvas id="canvasOutput"></canvas>
    </div>

    <div class="controls-area">
        <div class="slider-container">
            <div class="slider-header">
                <span>알약 감지 감도 (Threshold)</span>
                <span id="threshVal">100</span>
            </div>
            <input type="range" id="threshSlider" min="20" max="200" value="100" step="5">
            <div class="tip">* 슬라이더를 움직여서 비닐을 지우고 알약만 남기세요.</div>
        </div>

        <div class="btn-group">
            <button id="startBtn" disabled>카메라 시작</button>
            <button id="stopBtn" disabled>중지</button>
        </div>

        <div class="options">
            <input type="checkbox" id="debugCheck" checked>
            <label for="debugCheck">이진화 화면 보기 (설정용)</label>
        </div>
    </div>

    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady()" type="text/javascript"></script>

    <script type="text/javascript">
        let video, canvasOutput, ctxOutput;
        let streaming = false;
        let stream = null;
        let cv = null;
        let cap = null;
        
        // 메모리 관리를 위한 전역 변수
        let src = null, dst = null;
        let gray = null, tophat = null, binary = null;
        let hierarchy = null, contours = null;
        let kernel = null;

        function onOpenCvReady() {
            cv = window.cv;
            document.getElementById('status').innerText = '준비 완료.';
            initElements();
            document.getElementById('startBtn').disabled = false;
        }

        function initElements() {
            video = document.getElementById('videoInput');
            canvasOutput = document.getElementById('canvasOutput');
            ctxOutput = canvasOutput.getContext('2d');
            
            // 슬라이더 값 표시
            const slider = document.getElementById('threshSlider');
            const valDisplay = document.getElementById('threshVal');
            slider.oninput = function() { valDisplay.innerText = this.value; }

            document.getElementById('startBtn').onclick = startCamera;
            document.getElementById('stopBtn').onclick = stopCamera;
        }

        async function startCamera() {
            if (streaming) return;
            try {
                const constraints = {
                    video: {
                        facingMode: { ideal: 'environment' },
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    },
                    audio: false
                };
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                await video.play();
                
                video.width = video.videoWidth;
                video.height = video.videoHeight;
                canvasOutput.width = video.videoWidth;
                canvasOutput.height = video.videoHeight;

                cap = new cv.VideoCapture(video);
                src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
                dst = new cv.Mat(video.height, video.width, cv.CV_8UC4);
                gray = new cv.Mat();
                tophat = new cv.Mat();
                binary = new cv.Mat();
                hierarchy = new cv.Mat();
                contours = new cv.MatVector();
                
                // Top-Hat용 커널: 알약 크기보다 약간 커야 합니다 (지름 30px 설정)
                // 이 크기보다 넓게 퍼진 빛(비닐)은 배경으로 인식해 삭제합니다.
                kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(30, 30));

                streaming = true;
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('status').innerText = '슬라이더를 조절해 알약만 남기세요.';
                
                requestAnimationFrame(processVideo);
            } catch (err) {
                alert("카메라 시작 에러: " + err.message);
            }
        }

        function stopCamera() {
            if (!streaming) return;
            streaming = false;
            video.pause();
            video.srcObject = null;
            stream.getTracks().forEach(track => track.stop());
            
            // 메모리 해제
            if(src) src.delete(); if(dst) dst.delete();
            if(gray) gray.delete(); if(tophat) tophat.delete();
            if(binary) binary.delete(); if(kernel) kernel.delete();
            if(hierarchy) hierarchy.delete(); if(contours) contours.delete();

            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('status').innerText = '중지됨';
            ctxOutput.clearRect(0, 0, canvasOutput.width, canvasOutput.height);
        }

        function processVideo() {
            if (!streaming) return;

            try {
                cap.read(src);

                // 1. ROI 설정 (화면 중앙 50% 영역)
                let roiX = Math.floor(src.cols * 0.25);
                let roiY = Math.floor(src.rows * 0.25);
                let roiW = Math.floor(src.cols * 0.5);
                let roiH = Math.floor(src.rows * 0.5);
                let rect = new cv.Rect(roiX, roiY, roiW, roiH);
                let srcRoi = src.roi(rect);

                // 2. 그레이스케일 변환
                cv.cvtColor(srcRoi, gray, cv.COLOR_RGBA2GRAY);

                // 3. [핵심] Top-Hat 변환
                // "원본" - "열기(Opening)연산결과" = "작고 밝은 것(알약)"만 남음
                // 넓은 영역(비닐)은 Opening 연산에서 살아남아 원본과 비슷해지므로, 빼면 사라짐(검은색 0이 됨).
                cv.morphologyEx(gray, tophat, cv.MORPH_TOPHAT, kernel);

                // 4. 이진화 (Threshold)
                // 슬라이더 값으로 조절. Top-Hat 결과는 배경이 아주 어둡기 때문에
                // 적절한 값을 주면 알약만 하얗게 뜹니다.
                let threshValue = parseInt(document.getElementById('threshSlider').value);
                cv.threshold(tophat, binary, threshValue, 255, cv.THRESH_BINARY);

                // 5. 윤곽선 검출
                cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                // 6. 결과 그리기
                src.copyTo(dst);
                let count = 0;
                let isDebug = document.getElementById('debugCheck').checked;

                for (let i = 0; i < contours.size(); ++i) {
                    let contour = contours.get(i);
                    let area = cv.contourArea(contour);

                    // 면적 필터
                    if (area > 100 && area < 5000) {
                        // 1) 비율 검사
                        let boundingRect = cv.boundingRect(contour);
                        let aspectRatio = boundingRect.width / boundingRect.height;
                        
                        // 2) Solidity(단단함) 검사: 찌그러진 비닐 조각 제외
                        let hull = new cv.Mat();
                        cv.convexHull(contour, hull, false, true);
                        let hullArea = cv.contourArea(hull);
                        let solidity = area / hullArea;
                        hull.delete();

                        // 필터 조건: 비율이 적당하고(0.5~2.0), 모양이 단단한(0.85 이상) 것만
                        if (aspectRatio >= 0.5 && aspectRatio <= 2.0 && solidity > 0.85) {
                            // ROI 좌표를 전체 좌표로 변환
                            let p1 = new cv.Point(rect.x + boundingRect.x, rect.y + boundingRect.y);
                            let p2 = new cv.Point(p1.x + boundingRect.width, p1.y + boundingRect.height);
                            
                            // 감지된 알약 박스 그리기
                            cv.rectangle(dst, p1, p2, [0, 255, 0, 255], 3);
                            count++;
                        }
                    }
                }

                // ROI 가이드 박스
                cv.rectangle(dst, new cv.Point(roiX, roiY), new cv.Point(roiX + roiW, roiY + roiH), [255, 255, 0, 255], 2);

                // 디버그 모드: ROI 영역에 'Top-Hat 후 이진화된 화면' 덮어씌우기
                if (isDebug) {
                    let dstRoi = dst.roi(rect);
                    cv.cvtColor(binary, dstRoi, cv.COLOR_GRAY2RGBA);
                    dstRoi.delete();
                }

                cv.imshow('canvasOutput', dst);

                // 텍스트 출력
                ctxOutput.font = "bold 40px sans-serif";
                ctxOutput.fillStyle = "#00ff00";
                ctxOutput.strokeStyle = "black";
                ctxOutput.lineWidth = 3;
                let msg = `개수: ${count}`;
                ctxOutput.strokeText(msg, 30, 60);
                ctxOutput.fillText(msg, 30, 60);

                srcRoi.delete();

            } catch (err) {
                console.error(err);
            }
            requestAnimationFrame(processVideo);
        }
    </script>
</body>
</html>
