<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pill Detection (iOS Fix)</title>
    <style>
        body { display: flex; flex-direction: column; align-items: center; font-family: sans-serif; margin: 0; padding: 20px; }
        h2 { margin-bottom: 10px; }
        
        /* 컨테이너 스타일 */
        .container { position: relative; width: 100%; max-width: 640px; }
        
        /* 캔버스: 실제 결과가 보이는 곳 */
        canvas { width: 100%; border: 1px solid #ccc; background-color: #eee; }
        
        /* 비디오: 아이폰 호환성을 위해 display: none을 쓰지 않고 투명도와 위치로 숨김 */
        video { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 10px; 
            height: 10px; 
            opacity: 0; 
            pointer-events: none;
            z-index: -1;
        }

        .controls { margin-top: 15px; display: flex; gap: 10px; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
        
        /* 모바일 디버깅용 로그 창 */
        #log { 
            margin-top: 20px; 
            width: 90%; 
            height: 100px; 
            border: 1px solid #333; 
            overflow-y: scroll; 
            font-size: 12px; 
            background: #f9f9f9; 
            padding: 5px;
        }
    </style>
</head>
<body>

    <h2>Pill Counter (iOS)</h2>
    <div id="status">OpenCV Loading...</div>
    
    <div class="container">
        <video id="videoInput" playsinline webkit-playsinline muted></video>
        <canvas id="canvasOutput"></canvas>
    </div>

    <div class="controls">
        <button id="startBtn" disabled>Start Camera</button>
        <button id="stopBtn" disabled>Stop</button>
    </div>

    <div id="log">Log started...<br></div>

    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady()" type="text/javascript"></script>

<script type="text/javascript">
        let video, canvas, ctx;
        let streaming = false;
        let stream = null;
        let cv = null;
        let cap = null;  // VideoCapture 객체를 전역으로 관리
        let src = null;  // 메모리 할당 최적화

        function log(msg) {
            const logDiv = document.getElementById('log');
            logDiv.innerHTML += msg + "<br>";
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(msg);
        }

        function onOpenCvReady() {
            if (cv && cv.Mat) return;
            cv = window.cv;
            document.getElementById('status').innerText = 'OpenCV Ready';
            log("OpenCV Library Loaded");
            
            setTimeout(() => {
                initElements();
                document.getElementById('startBtn').disabled = false;
            }, 500);
        }

        function initElements() {
            video = document.getElementById('videoInput');
            canvas = document.getElementById('canvasOutput');
            ctx = canvas.getContext('2d');

            document.getElementById('startBtn').onclick = startCamera;
            document.getElementById('stopBtn').onclick = stopCamera;
        }

        async function startCamera() {
            if (streaming) return;
            log("Requesting Camera...");

            try {
                const constraints = {
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 640 }, // 해상도 요청
                        height: { ideal: 480 }
                    },
                    audio: false
                };

                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    log(`Raw Video Size: ${video.videoWidth}x${video.videoHeight}`);
                    
                    video.play().then(() => {
                        // [핵심 수정] 비디오 태그의 물리적 속성을 스트림 크기와 강제 일치시킴
                        video.width = video.videoWidth;
                        video.height = video.videoHeight;
                        
                        // 캔버스 크기도 동기화
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        
                        // OpenCV 객체 초기화 (한 번만 수행)
                        if (cap) { delete cap; cap = null; } // 혹시 모를 잔여물 제거
                        cap = new cv.VideoCapture(video);
                        
                        // 입력 매트릭스 초기화
                        if (src) src.delete();
                        src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);

                        log(`Initialized: ${video.width}x${video.height}`);

                        streaming = true;
                        document.getElementById('startBtn').disabled = true;
                        document.getElementById('stopBtn').disabled = false;
                        
                        requestAnimationFrame(processVideo);
                    }).catch(e => {
                        log("Play Error: " + e);
                    });
                };
            } catch (err) {
                log("Camera Error: " + err.message);
                alert("카메라 에러: " + err.message);
            }
        }

        function stopCamera() {
            if (!streaming) return;
            log("Stopping Camera...");

            streaming = false;
            video.pause();
            video.srcObject = null;
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            
            // 메모리 정리
            if (src) { src.delete(); src = null; }
            // cap은 JS 래퍼라 delete 메서드가 없을 수 있으나, 보통 가비지 컬렉션 됨. 
            // 명시적으로 null 처리.
            cap = null; 

            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function processVideo() {
            if (!streaming) return;

            try {
                // 비디오 크기 변경 감지 (가로/세로 회전 시 대응)
                if (video.videoWidth !== src.cols || video.videoHeight !== src.rows) {
                     log(`Resizing... ${video.videoWidth}x${video.videoHeight}`);
                     video.width = video.videoWidth;
                     video.height = video.videoHeight;
                     canvas.width = video.videoWidth;
                     canvas.height = video.videoHeight;
                     
                     src.delete();
                     src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
                }

                // 프레임 읽기 (전역 객체 cap 사용)
                cap.read(src);

                let dst = new cv.Mat();
                let count = detectPills(src, dst);

                cv.imshow('canvasOutput', dst);

                ctx.font = "bold 30px Arial";
                ctx.fillStyle = "red";
                ctx.fillText(`Pills: ${count}`, 20, 50);

                dst.delete();

            } catch (err) {
                // 특정 프레임 에러는 무시하고 계속 진행 시도
                console.error(err); 
                // 치명적이면 streaming = false;
            }

            if (streaming) {
                requestAnimationFrame(processVideo);
            }
        }

        function detectPills(src, dst) {
            let gray = new cv.Mat();
            let blurred = new cv.Mat();
            let binary = new cv.Mat();
            let contours = new cv.MatVector();
            let hierarchy = new cv.MatVector();

            // 전처리
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
            cv.threshold(blurred, binary, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);

            // 형태학적 연산
            let M = cv.Mat.ones(3, 3, cv.CV_8U);
            cv.morphologyEx(binary, binary, cv.MORPH_OPEN, M);

            // 윤곽선
            cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

            src.copyTo(dst);
            
            let count = 0;
            // 아이폰 고해상도 고려하여 최소 면적 상향 (환경에 따라 조절)
            const minArea = 500; 

            for (let i = 0; i < contours.size(); ++i) {
                let contour = contours.get(i);
                let area = cv.contourArea(contour);

                if (area > minArea) {
                    // 원형 근사화 (선택사항)
                    // let circle = cv.minEnclosingCircle(contour);
                    // cv.circle(dst, circle.center, circle.radius, new cv.Scalar(0, 255, 0, 255), 2);
                    
                    cv.drawContours(dst, contours, i, new cv.Scalar(0, 255, 0, 255), 3, cv.LINE_8, hierarchy, 0);
                    count++;
                }
            }

            gray.delete(); blurred.delete(); binary.delete();
            contours.delete(); hierarchy.delete(); M.delete();

            return count;
        }
    </script>
</body>
</html>

