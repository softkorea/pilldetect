<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pill Detection (iOS Fix)</title>
    <style>
        body { display: flex; flex-direction: column; align-items: center; font-family: sans-serif; margin: 0; padding: 20px; }
        h2 { margin-bottom: 10px; }
        
        /* 컨테이너 스타일 */
        .container { position: relative; width: 100%; max-width: 640px; }
        
        /* 캔버스: 실제 결과가 보이는 곳 */
        canvas { width: 100%; border: 1px solid #ccc; background-color: #eee; }
        
        /* 비디오: 아이폰 호환성을 위해 display: none을 쓰지 않고 투명도와 위치로 숨김 */
        video { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 10px; 
            height: 10px; 
            opacity: 0; 
            pointer-events: none;
            z-index: -1;
        }

        .controls { margin-top: 15px; display: flex; gap: 10px; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
        
        /* 모바일 디버깅용 로그 창 */
        #log { 
            margin-top: 20px; 
            width: 90%; 
            height: 100px; 
            border: 1px solid #333; 
            overflow-y: scroll; 
            font-size: 12px; 
            background: #f9f9f9; 
            padding: 5px;
        }
    </style>
</head>
<body>

    <h2>Pill Counter (iOS)</h2>
    <div id="status">OpenCV Loading...</div>
    
    <div class="container">
        <video id="videoInput" playsinline webkit-playsinline muted></video>
        <canvas id="canvasOutput"></canvas>
    </div>

    <div class="controls">
        <button id="startBtn" disabled>Start Camera</button>
        <button id="stopBtn" disabled>Stop</button>
    </div>

    <div id="log">Log started...<br></div>

    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady()" type="text/javascript"></script>

    <script type="text/javascript">
        let video, canvas, ctx;
        let streaming = false;
        let stream = null;
        let cv = null;

        // 화면에 로그 찍기 함수 (폰에서 에러 확인용)
        function log(msg) {
            const logDiv = document.getElementById('log');
            logDiv.innerHTML += msg + "<br>";
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(msg);
        }

        function onOpenCvReady() {
            if (cv && cv.Mat) return; // 이미 로드되었으면 패스
            cv = window.cv;
            document.getElementById('status').innerText = 'OpenCV Ready';
            log("OpenCV Library Loaded");
            
            // OpenCV 초기화가 비동기로 될 수 있어 잠시 대기 후 버튼 활성화
            setTimeout(() => {
                initElements();
                document.getElementById('startBtn').disabled = false;
            }, 500);
        }

        function initElements() {
            video = document.getElementById('videoInput');
            canvas = document.getElementById('canvasOutput');
            ctx = canvas.getContext('2d');

            document.getElementById('startBtn').onclick = startCamera;
            document.getElementById('stopBtn').onclick = stopCamera;
        }

        async function startCamera() {
            if (streaming) return;
            log("Requesting Camera...");

            try {
                // 아이폰 후면 카메라 요청
                const constraints = {
                    video: {
                        facingMode: 'environment', // 후면 카메라
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    },
                    audio: false
                };

                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                // 비디오 메타데이터 로드 대기 (중요)
                video.onloadedmetadata = () => {
                    log(`Video Meta Loaded: ${video.videoWidth}x${video.videoHeight}`);
                    video.play().then(() => {
                        log("Video playing...");
                        
                        // 캔버스 크기를 비디오 실제 크기에 맞춤
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        
                        streaming = true;
                        document.getElementById('startBtn').disabled = true;
                        document.getElementById('stopBtn').disabled = false;
                        
                        requestAnimationFrame(processVideo);
                    }).catch(e => {
                        log("Play Error: " + e);
                    });
                };
            } catch (err) {
                log("Camera Error: " + err.name + " - " + err.message);
                alert("카메라 에러: " + err.message);
            }
        }

        function stopCamera() {
            if (!streaming) return;
            log("Stopping Camera...");

            streaming = false;
            video.pause();
            video.srcObject = null;
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function processVideo() {
            if (!streaming) return;

            try {
                // 비디오 크기가 0이거나 준비 안됐으면 스킵
                if (video.videoWidth === 0 || video.videoHeight === 0) {
                    requestAnimationFrame(processVideo);
                    return;
                }

                let src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
                let cap = new cv.VideoCapture(video);
                
                // 프레임 읽기
                cap.read(src);

                // 알약 감지
                let dst = new cv.Mat();
                let count = detectPills(src, dst);

                // 결과 출력
                cv.imshow('canvasOutput', dst);

                // 텍스트 그리기
                ctx.font = "24px Arial";
                ctx.fillStyle = "red";
                ctx.lineWidth = 1;
                ctx.fillText(`Count: ${count}`, 20, 40);

                // 메모리 해제
                src.delete();
                dst.delete();
                // cap은 JS 래퍼라 명시적 delete 안 해도 되지만 루프 안이라 주의 필요할 수도 있음.
                // 여기선 imshow 후라 안전.

            } catch (err) {
                log("Process Error: " + err);
                streaming = false; // 에러나면 멈춤
            }

            if (streaming) {
                requestAnimationFrame(processVideo);
            }
        }

        function detectPills(src, dst) {
            let gray = new cv.Mat();
            let blurred = new cv.Mat();
            let binary = new cv.Mat();
            let contours = new cv.MatVector();
            let hierarchy = new cv.MatVector();

            // 1. 전처리
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
            cv.threshold(blurred, binary, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);

            // 2. 형태학적 연산
            let M = cv.Mat.ones(3, 3, cv.CV_8U);
            cv.morphologyEx(binary, binary, cv.MORPH_OPEN, M);

            // 3. 윤곽선
            cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

            // 4. 그리기
            src.copyTo(dst);
            let count = 0;
            // 아이폰 해상도가 높을 수 있으므로 면적 기준을 조금 높임 (조정 필요)
            const minArea = 1000; 

            for (let i = 0; i < contours.size(); ++i) {
                let contour = contours.get(i);
                let area = cv.contourArea(contour);

                if (area > minArea) {
                    cv.drawContours(dst, contours, i, new cv.Scalar(0, 255, 0, 255), 3, cv.LINE_8, hierarchy, 0);
                    count++;
                }
            }

            gray.delete(); blurred.delete(); binary.delete();
            contours.delete(); hierarchy.delete(); M.delete();

            return count;
        }
    </script>
</body>
</html>
