<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pill Detection (ROI & Otsu)</title>
    <style>
        body { 
            display: flex; flex-direction: column; align-items: center; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0; padding: 20px; box-sizing: border-box; background: #222; color: #eee;
            touch-action: manipulation;
        }
        h3 { margin: 10px 0; color: #fff; }
        #status { font-size: 14px; color: #ccc; margin-bottom: 10px; height: 20px; }
        
        .container { 
            position: relative; 
            width: 100%; max-width: 640px; 
            aspect-ratio: 3 / 4; 
            background: #000;
            border-radius: 12px; overflow: hidden; box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        
        canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover;
        }
        #videoInput { display: none; } /* 비디오 태그는 숨김 (OpenCV 처리용) */

        .controls { margin-top: 20px; z-index: 3; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
        button { 
            padding: 12px 24px; font-size: 16px; font-weight: 600;
            cursor: pointer; border-radius: 8px; border: none; 
            background: #0a84ff; color: white; transition: background 0.2s;
        }
        button:disabled { background: #555; color: #888; cursor: not-allowed; }
        button#stopBtn { background: #ff453a; }
        button#stopBtn:disabled { background: #555; }

        .options { margin-top: 15px; display: flex; gap: 15px; align-items: center; }
        label { cursor: pointer; user-select: none; font-size: 14px; }

        #log { 
            margin-top: 20px; width: 100%; max-width: 640px; height: 100px; 
            border: 1px solid #444; border-radius: 8px;
            overflow-y: scroll; font-size: 11px; background: #333; 
            padding: 8px; font-family: monospace; color: #ccc;
        }
    </style>
</head>
<body>

    <h3>알약 카운터 (포장지 대응)</h3>
    <div id="status">OpenCV 로딩 중...</div>
    
    <div class="container">
        <video id="videoInput" playsinline webkit-playsinline muted></video>
        <canvas id="canvasOutput"></canvas>
    </div>

    <div class="controls">
        <button id="startBtn" disabled>카메라 시작</button>
        <button id="stopBtn" disabled>중지</button>
    </div>

    <div class="options">
        <label><input type="checkbox" id="debugCheck"> 이진화 화면 보기 (디버그)</label>
    </div>

    <div id="log">로그 시작...<br></div>

    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady()" type="text/javascript"></script>

    <script type="text/javascript">
        let video, canvasOutput, ctxOutput;
        let streaming = false;
        let stream = null;
        let cv = null;
        let cap = null;
        
        // 메모리 효율을 위해 전역 변수로 선언
        let src = null;
        let dst = null;
        let gray = null, blurred = null, binary = null;
        let hierarchy = null, contours = null;

        function log(msg) {
            const logDiv = document.getElementById('log');
            logDiv.innerHTML = `> ${msg}<br>` + logDiv.innerHTML.substring(0, 1000);
        }

        function onOpenCvReady() {
            cv = window.cv;
            document.getElementById('status').innerText = '준비 완료. 카메라를 시작하세요.';
            log("OpenCV 로드됨");
            initElements();
            document.getElementById('startBtn').disabled = false;
        }

        function initElements() {
            video = document.getElementById('videoInput');
            canvasOutput = document.getElementById('canvasOutput');
            ctxOutput = canvasOutput.getContext('2d');

            document.getElementById('startBtn').onclick = startCamera;
            document.getElementById('stopBtn').onclick = stopCamera;
        }

        async function startCamera() {
            if (streaming) return;
            try {
                const constraints = {
                    video: {
                        facingMode: { ideal: 'environment' },
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    },
                    audio: false
                };
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                await video.play();
                
                video.width = video.videoWidth;
                video.height = video.videoHeight;
                canvasOutput.width = video.videoWidth;
                canvasOutput.height = video.videoHeight;

                // OpenCV 객체 초기화
                cap = new cv.VideoCapture(video);
                src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
                dst = new cv.Mat(video.height, video.width, cv.CV_8UC4);
                gray = new cv.Mat();
                blurred = new cv.Mat();
                binary = new cv.Mat();
                hierarchy = new cv.Mat();
                contours = new cv.MatVector();

                streaming = true;
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('status').innerText = '초록 박스 안에 알약을 놓으세요.';
                
                requestAnimationFrame(processVideo);
            } catch (err) {
                log("에러: " + err.message);
                alert("카메라 시작 실패");
            }
        }

        function stopCamera() {
            if (!streaming) return;
            streaming = false;
            video.pause();
            video.srcObject = null;
            stream.getTracks().forEach(track => track.stop());
            
            // 메모리 해제
            if(src) src.delete(); if(dst) dst.delete();
            if(gray) gray.delete(); if(blurred) blurred.delete();
            if(binary) binary.delete();
            if(hierarchy) hierarchy.delete(); if(contours) contours.delete();

            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('status').innerText = '중지됨';
            ctxOutput.clearRect(0, 0, canvasOutput.width, canvasOutput.height);
        }

        function processVideo() {
            if (!streaming) return;

            try {
                cap.read(src);

                // 1. ROI 설정 (화면 중앙 50% 영역만 사용)
                // 배경 잡동사니 제거를 위해 중앙만 잘라냅니다.
                let roiX = Math.floor(src.cols * 0.25);
                let roiY = Math.floor(src.rows * 0.25);
                let roiW = Math.floor(src.cols * 0.5);
                let roiH = Math.floor(src.rows * 0.5);
                let rect = new cv.Rect(roiX, roiY, roiW, roiH);
                
                // ROI 잘라내기 (이미지 복사가 아닌 참조 생성)
                let srcRoi = src.roi(rect);
                
                // 2. 전처리
                cv.cvtColor(srcRoi, gray, cv.COLOR_RGBA2GRAY);
                // 노이즈(비닐 주름) 제거를 위해 블러를 약간 강하게 줌
                cv.GaussianBlur(gray, blurred, new cv.Size(7, 7), 0);

                // 3. 이진화 (Otsu 알고리즘)
                // Adaptive 대신 Otsu를 사용하여 배경과 알약을 자동으로 가장 잘 나누는 값을 찾습니다.
                cv.threshold(blurred, binary, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU);

                // 4. 형태학적 연산 (구멍 메우기)
                let kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(5, 5));
                // 팽창(Dilate)으로 알약 내부의 검은 반사광 구멍을 메움
                cv.morphologyEx(binary, binary, cv.MORPH_DILATE, kernel);
                cv.morphologyEx(binary, binary, cv.MORPH_CLOSE, kernel);

                // 5. 윤곽선 검출
                cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                // 6. 그리기 및 필터링
                src.copyTo(dst); // 원본 복사
                let count = 0;
                let isDebug = document.getElementById('debugCheck').checked;

                for (let i = 0; i < contours.size(); ++i) {
                    let contour = contours.get(i);
                    let area = cv.contourArea(contour);

                    // 면적 필터 (ROI 내부 기준이므로 픽셀 수가 작을 수 있음)
                    if (area > 300 && area < 8000) {
                        let boundingRect = cv.boundingRect(contour);
                        let aspectRatio = boundingRect.width / boundingRect.height;
                        
                        // Solidity (단단함/채움 비율) 체크 [핵심]
                        // 알약은 매끈한 타원형이므로 Solidity가 높습니다 (1에 가까움).
                        // 찌그러진 비닐 반사광은 모양이 불규칙하여 Solidity가 낮습니다.
                        let hull = new cv.Mat();
                        cv.convexHull(contour, hull, false, true);
                        let hullArea = cv.contourArea(hull);
                        let solidity = area / hullArea;
                        hull.delete();

                        // 필터 조건: 비율(0.5~2.0) 그리고 Solidity(0.85 이상)
                        if (aspectRatio >= 0.5 && aspectRatio <= 2.0 && solidity > 0.85) {
                            // ROI 좌표를 원본 좌표로 변환하여 박스 그리기
                            let p1 = new cv.Point(rect.x + boundingRect.x, rect.y + boundingRect.y);
                            let p2 = new cv.Point(p1.x + boundingRect.width, p1.y + boundingRect.height);
                            cv.rectangle(dst, p1, p2, [0, 255, 0, 255], 3);
                            count++;
                        }
                    }
                }

                // 7. 결과 화면 표시
                // ROI 가이드 박스 (파란색) - 여기에 맞춰달라고 표시
                cv.rectangle(dst, new cv.Point(roiX, roiY), new cv.Point(roiX + roiW, roiY + roiH), [255, 255, 0, 255], 2);

                if (isDebug) {
                    // 디버그 모드: 처리된 흑백 이미지를 ROI 영역에 덮어씌워 보여줌
                    // 이를 통해 비닐 반사가 어떻게 보이는지 확인 가능
                    let dstRoi = dst.roi(rect);
                    cv.cvtColor(binary, dstRoi, cv.COLOR_GRAY2RGBA);
                    dstRoi.delete();
                }

                cv.imshow('canvasOutput', dst);

                // 텍스트 출력
                ctxOutput.font = "bold 40px sans-serif";
                ctxOutput.fillStyle = "#00ff00";
                ctxOutput.strokeStyle = "black";
                ctxOutput.lineWidth = 3;
                let msg = `개수: ${count}`;
                ctxOutput.strokeText(msg, 30, 60);
                ctxOutput.fillText(msg, 30, 60);

                // 메모리 정리 (ROI 객체 해제)
                srcRoi.delete(); kernel.delete();

            } catch (err) {
                console.error(err);
            }
            requestAnimationFrame(processVideo);
        }
    </script>
</body>
</html>
